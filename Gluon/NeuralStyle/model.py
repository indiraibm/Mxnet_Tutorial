import numpy as npimport mxnet as mximport mxnet.gluon as gluonimport mxnet.ndarray as ndimport mxnet.autograd as autogradfrom tqdm import *importimport osdef data_preprocessing():    passdef Stylized_Image(network, ctx):    numerator = 0    denominator = 0        for data, label in data_iterator:        data = data.as_in_context(ctx)        label = label.as_in_context(ctx)        output = network(data)  # when test , 'Dropout rate' must be 0.0        predictions = nd.argmax(output, axis=1)  # (batch_size , num_outputs)        predictions = predictions.asnumpy()        label = label.asnumpy()        numerator += sum(predictions == label)        denominator += data.shape[0]    return (numerator / denominator)def NeuralStyle(epoch = 100, save_period = 100, load_period = 100, optimizer = "adam", learning_rate = 0.001, content_image = None, style_image = None, content_a = None, style_b = None, ctx = mx.cpu(0)):    vgg19=gluon.model_zoo.vision.vgg19(pretrained=True ,ctx = ctx)    vgg19.collect_params()    #data selection    if dataset =="MNIST":        train_data , test_data = MNIST(batch_size)        path = "weights/MNIST-{}.params".format(load_period)    elif dataset == "CIFAR10":        train_data, test_data = CIFAR10(batch_size)        path = "weights/CIFAR10-{}.params".format(load_period)    elif dataset == "FashionMNIST":        train_data, test_data = FashionMNIST(batch_size)        path = "weights/FashionMNIST-{}.params".format(load_period)    else:        return "The dataset does not exist."    #1 . Neural Style Transfer Network    net = gluon.nn.HybridSequential()  # stacks 'Block's sequentially    with net.name_scope():        net.add(gluon.nn.Conv2D(channels=60, kernel_size=(3, 3), strides=(1, 1), use_bias=True, activation="relu"))        net.add(gluon.nn.MaxPool2D(pool_size=(2, 2), strides=(2, 2)))        net.add(gluon.nn.Conv2D(channels=30, kernel_size=(6, 6), strides=(1, 1), use_bias=True, activation="relu"))        net.add(gluon.nn.MaxPool2D(pool_size=(2, 2), strides=(2, 2)))        net.add(gluon.nn.Dense(units=120, activation="sigmoid", use_bias=True, flatten=True))        net.add(gluon.nn.Dropout(0.2))        net.add(gluon.nn.Dense(units=64, activation="sigmoid", use_bias=True))        net.add(gluon.nn.Dropout(0.2))        net.add(gluon.nn.Dense(10, use_bias=True))    #for faster learning    net.hybridize()    # weights initialization    if os.path.exists(path):        print("loading weights")        net.load_params(filename=path, ctx=ctx)  # weights load    else:        print("initializing weights")        net.collect_params().initialize(mx.init.Normal(sigma=0.1), ctx=ctx)  # weights initialization        # net.initialize(mx.init.Normal(sigma=0.1),ctx=ctx) # weights initialization    # optimizer    trainer = gluon.Trainer(net.collect_params(), optimizer, {"learning_rate": learning_rate})    # learning process    for i in tqdm(range(1, epoch + 1, 1)):        for data, label in train_data:            data = data.as_in_context(ctx)            label = label.as_in_context(ctx)            with autograd.record(train_mode=True):                output = net(data)                # loss definition                '''Why do you write this?                answer :  Blocks, sequential, softmaxCrossEntropyLoss, and other gluon package keywords should be accessed as classes by default.'''                loss = gluon.loss.SoftmaxCrossEntropyLoss(axis=-1, sparse_label=True)(output,label)  # if sparse_label=True , need 'one hot encoding' of label                cost = nd.mean(loss).asscalar()            loss.backward()            trainer.step()        print(" epoch : {} , last batch cost : {}".format(i, cost))        # weight_save        if i % save_period == 0:            if not os.path.exists("weights"):                os.makedirs("weights")            print("saving weights")            net.save_params("weights/MNIST-{}.params".format(i))        Stylized_Image(net, ctx)    return "optimization completed"if __name__ == "__main__":    content_image = " "    style_image = " "    NeuralStyle(epoch = 0, save_period = 100, load_period = 100, optimizer = "adam", learning_rate = 0.001, content_image = content_image, style_image = style_image, content_a = 1, style_b = 1000, ctx = mx.cpu(0))else:    print("Imported")